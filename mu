2 fundamentals-of-algorithms/
3 fundamentals-of-algorithms/
4 searching-algorithms/
5 sorting-algorithms/
6 graph-data-structure-and-algorithms/
7 bitwise-algorithms/
8 geometric-algorithms/
9 mathematical-algorithms/
10 randomized-algorithms/
11 fundamentals-of-algorithms/
12 greedy-algorithms/
13 dynamic-programming/
14 divide-and-conquer/
15 backtracking-algorithms/
16 fundamentals-of-algorithms/
17 data-structures/
18 array-data-structure/
19 data-structures/linked-list/
20 stack-data-structure/
21 queue-data-structure/
22 data-structures/
23 binary-tree-data-structure/
24 binary-search-tree-data-structure/
25 heap-data-structure/
26 hashing-data-structure/
27 graph-data-structure-and-algorithms/
28 advanced-data-structures/
29 matrix/
30 string-data-structure/
31 data-structures/
32 c/
33 c-plus-plus/
34 java/
35 python/
36 sql-tutorial/
37 company-preparation/
38 interview-preparation-for-software-developer/
39 software-design-patterns/
40 student-corner/
41 campus-ambassador-program-by-geeksforgeeks/
42 geek-of-the-month/
43 testimonials/
44 careers/
45 internship/
46 school-programming/
47 gate-corner-2-gq/
48 gate-corner-2-gq/
49 gate-cs-notes-gq/
50 lmns-gq/
51 original-gate-previous-year-question-papers-cse-and-it-gq/
52 gate-cs-2018-important-dates/
53 articles-on-computer-science-subjects-gq/
54 operating-systems/
55 dbms/
56 computer-network-tutorials/
57 compiler-design-tutorials/
58 web-technology/
59 computer-organization-and-architecture-tutorials/
60 digital-electronics-logic-design-tutorials/
61 engineering-mathematics-tutorials/
62 theory-of-computation-automata-tutorials/
63 advanced-computer-subjects-tutorials/
64 software-engineering-gq/
65 html-and-xml-gq/
66 puzzles/
67 the-technical-scripter-event-by-geeksforgeeks-2/
68 write-interview-experience/
69 must-coding-questions-company-wise/
70 basic/
71 easy/
72 medium/
73 hard/
74 expert/
75 tag/amazon/
76 tag/dynamic-programming/
77 tag/samsung/
78 tags/
79 a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
80 company-preparation/
81 interview-preparation-for-software-developer/
82 software-design-patterns/
83 placements-gq/
84 company-interview-corner/
85 lmns-gq/
86 c/
87 c-plus-plus/
88 java/
89 python/
90 sql-tutorial/
91 school-programming/
92 operating-systems/
93 dbms/
94 computer-network-tutorials/
95 engineering-mathematics-tutorials/
96 web-technology/
97 tag/computer-graphics/
98 image-processing/
99 johnson-trotter-algorithm/
100 easy/
101 johnson-trotter-algorithm/
102 print-reverse-linked-list-without-extra-space-modifications/
103 easy/
104 print-reverse-linked-list-without-extra-space-modifications/
105 tag/programming-puzzle/
106 circular-array/
107 easy/
108 circular-array/
109 tag/circular-array/
110 value-k-th-index-series-formed-append-insert-mex-middle/
111 value-k-th-index-series-formed-append-insert-mex-middle/
112 tag/binary-search/
113 insert-whole-linked-list-k-th-position/
114 insert-whole-linked-list-k-th-position/
115 trinomial-triangle/
116 trinomial-triangle/
117 output-java-programs-set-54-vectors/
118 output-java-programs-set-54-vectors/
119 tag/java-util-package/
120 python-minimum-number-subsets-distinct-elements-using-counter/
121 python-minimum-number-subsets-distinct-elements-using-counter/
122 tag/python-dict/
123 tag/python-set/
124 python-find-number-occurring-odd-number-times-using-lambda-expression-reduce-function/
125 python-find-number-occurring-odd-number-times-using-lambda-expression-reduce-function/
126 tag/python-string/
127 find-minimum-number-operation-make-array-decreasing/
128 find-minimum-number-operation-make-array-decreasing/
129 priority_queuetop-c-stl/
130 priority_queuetop-c-stl/
131 tag/cpp-library/
132 tag/cpp-queue/
133 tag/stl/
134 minimum-equal-palindromic-cuts-with-rearrangements-allowed/
135 minimum-equal-palindromic-cuts-with-rearrangements-allowed/
136 tag/palindrome/
137 priority_queuepush-priority_queuepop-c-stl/
138 priority_queuepush-priority_queuepop-c-stl/
139 tag/cpp-library/
140 tag/cpp-queue/
141 tag/stl/
142 program-find-sum-series-11-22-33-44-55-nn/
143 basic/
144 program-find-sum-series-11-22-33-44-55-nn/
145 tag/number-theory/
146 tag/series/
147 find-largest-sum-digits-divisors-n/
148 find-largest-sum-digits-divisors-n/
149 tag/number-digits/
150 program-get-sum-series-1-x22-x44-upto-nth-term/
151 program-get-sum-series-1-x22-x44-upto-nth-term/
152 tag/factorial/
153 tag/series/
154 iterative-searching-binary-search-tree/
155 iterative-searching-binary-search-tree/
156 smallest-subset-sum-greater-elements/
157 medium/
158 smallest-subset-sum-greater-elements/
159 longest-common-subsequence/
160 breadth-first-traversal-for-a-graph/
161 school-programming/
162 longest-repeated-subsequence/
163 dynamic-programming-set-12-longest-palindromic-subsequence/
164 detect-negative-cycle-graph-bellman-ford/
165 knapsack-problem/
166 gate-cs-notes-gq/
167 depth-first-traversal-for-a-graph/
168 reverse-a-linked-list/
169 top-algorithms-and-data-structures-for-competitive-programming/
170 top-10-algorithms-in-interview-questions/
171 how-to-begin-with-competitive-programming/
172 a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
173 how-to-prepare-for-acm-icpc/
174 advanced-data-structures/
175 dynamic-programming/
176 tag/recursion
177 tag/statistical-algorithms/
178 tag/amazon/
179 tag/aptitude/
180 tag/c/
181 tag/cpp-library/
182 tag/data-structures/
183 tag/number-digits/
184 tag/series/
185 tag/stl/
186 recent-comments/
187 careers/




-----------------------------------------------NEXT OPTIONS----------------------------------------
2 breadth-first-traversal-for-a-graph/
3 depth-first-traversal-for-a-graph/
4 applications-of-depth-first-search/
5 applications-of-breadth-first-traversal/
6 find-longest-path-directed-acyclic-graph/
7 find-a-mother-vertex-in-a-graph/
8 transitive-closure-of-a-graph-using-dfs/
9 find-k-cores-graph/
10 iterative-depth-first-traversal/
11 iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/
12 detect-cycle-in-a-graph/
13 union-find/
14 detect-cycle-undirected-graph/
15 detect-cycle-direct-graph-using-colors/
16 assign-directions-to-edges-so-that-the-directed-graph-remains-acyclic/
17 detect-negative-cycle-graph-bellman-ford/
18 topological-sorting/
19 all-topological-sorts-of-a-directed-acyclic-graph/
20 topological-sorting-indegree-based-solution/
21 greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/
22 applications-of-minimum-spanning-tree/
23 greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/
24 greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/
25 greedy-algorithms-set-9-boruvkas-algorithm/
26 steiner-tree/
27 find-if-there-is-a-path-of-more-than-k-length-from-a-source/
28 tug-of-war/
29 backtracking-set-1-the-knights-tour-problem/
30 backttracking-set-2-rat-in-a-maze/
31 backtracking-set-3-n-queen-problem/
32 backttracking-set-5-m-coloring-problem/
33 backtracking-set-7-hamiltonian-cycle/
34 greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/
35 greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/
36 dynamic-programming-set-23-bellman-ford-algorithm/
37 dynamic-programming-set-16-floyd-warshall-algorithm/
38 johnsons-algorithm/
39 shortest-path-for-directed-acyclic-graphs/
40 interesting-shortest-path-questions-set-1/
41 shortest-path-exactly-k-edges-directed-weighted-graph/
42 dials-algorithm-optimized-dijkstra-for-small-range-weights/
43 printing-paths-dijkstras-shortest-path-algorithm/
44 shortest-path-weighted-graph-weight-edge-1-2/
45 find-if-there-is-a-path-between-two-vertices-in-a-given-graph/
46 connectivity-in-a-directed-graph/
47 articulation-points-or-cut-vertices-in-a-graph/
48 biconnectivity-in-a-graph/
49 bridge-in-a-graph/
50 eulerian-path-and-circuit/
51 fleurys-algorithm-for-printing-eulerian-path/
52 strongly-connected-components/
53 transitive-closure-of-a-graph/
54 find-number-of-islands/
55 count-possible-paths-source-destination-exactly-k-edges/
56 euler-circuit-directed-graph/
57 biconnected-components/
58 kargers-algorithm-for-minimum-cut-set-1-introduction-and-implementation/
59 find-if-there-is-a-path-of-more-than-k-length-from-a-source/
60 length-of-shortest-chain-to-reach-a-target-word/
61 find-paths-given-source-destination/
62 find-the-minimum-cost-to-reach-a-destination-where-every-station-is-connected-in-one-direction/
63 tarjan-algorithm-find-strongly-connected-components/
64 graph-coloring-applications/
65 graph-coloring-set-2-greedy-algorithm/
66 travelling-salesman-problem-set-1/
67 travelling-salesman-problem-set-2-approximate-using-mst/
68 backtracking-set-7-hamiltonian-cycle/
69 vertex-cover-problem-set-1-introduction-approximate-algorithm-2/
70 k-centers-problem-set-1-greedy-approximate-algorithm/
71 ford-fulkerson-algorithm-for-maximum-flow-problem/
72 find-edge-disjoint-paths-two-vertices/
73 minimum-cut-in-a-directed-graph/
74 maximum-bipartite-matching/
75 channel-assignment-problem/
76 push-relabel-algorithm-set-1-introduction-and-illustration/
77 push-relabel-algorithm-set-2-implementation/
78 kargers-algorithm-for-minimum-cut-set-1-introduction-and-implementation/
79 kargers-algorithm-for-minimum-cut-set-2-analysis-and-applications/
80 kruskals-minimum-spanning-tree-using-stl-in-c/
81 prims-algorithm-using-priority_queue-stl/
82 dijkstras-shortest-path-algorithm-using-priority_queue-stl/
83 dijkstras-shortest-path-algorithm-using-set-in-stl/
84 number-of-triangles-in-a-undirected-graph/
85 number-of-triangles-in-directed-and-undirected-graphs/
86 bipartite-graph/
87 snake-ladder-problem-2/
88 bipartite-graph/
89 boggle-find-possible-words-board-characters/
90 hopcroft-karp-algorithm-for-maximum-matching-set-1-introduction/
91 hopcroft-karp-algorithm-for-maximum-matching-set-2-implementation/
92 minimum-time-required-so-that-all-oranges-become-rotten/
93 find-same-contacts-in-a-list-of-contacts/
94 optimal-read-list-given-number-days/
95 print-all-jumping-numbers-smaller-than-or-equal-to-a-given-value/
96 data-structures/
97 mit?url=https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/&title=Graph Data Structure And Algorithms
98 





We strongly recommend to refer below post as a prerequisite.
Hopcroft–Karp Algorithm for Maximum Matching | Set 1 (Introduction)
There are few important things to note before we start implementation.

We need to find an augmenting path (A path that alternates between matching and not matching edges, and has free vertices as starting and ending points).
Once we find alternating path, we need to add the found path to existing Matching. Here adding path means, making previous matching edges on this path as not-matching and previous not-matching edges as matching.

The idea is to use BFS (Breadth First Search) to find augmenting paths. Since BFS traverses level by level, it is used to divide the graph in layers of matching and not matching edges.  A dummy vertex NIL is added that is connected to all vertices on left side and all vertices on right side.  Following arrays are used to find augmenting path.  Distance to NIL is initialized as INF (infinite).  If we start from dummy vertex and come back to it using alternating path of distinct vertices, then there is an augmenting path.

 pairU[]: An array of size m+1 where m is number of vertices on left side of Bipartite Graph. pairU[u] stores pair of u on right side if u is matched and NIL otherwise.
 pairV[]: An array of size n+1 where n is number of vertices on right side of Bipartite Graph. pairU[v] stores pair of v on left side if v is matched and NIL otherwise.
 dist[]: An array of size m+1 where m is number of vertices on left side of Bipartite Graph.  dist[u] is initialized as 0 if u is not matching and INF (infinite) otherwise. dist[] of NIL is also initialized as INF

Once an augmenting path is found, DFS (Depth First Search) is used to add augmenting paths to current matching.  DFS simply follows the distance array setup by BFS.  It fills values in pairU[u] and pairV[v] if v is next to u in BFS.  
Below is C++ implementation of above Hopkroft Karp algorithm.

// C++ implementation of Hopcroft Karp algorithm for
// maximum matching
#include<bits/stdc++.h>
using namespace std;
#define NIL 0
#define INF INT_MAX

// A class to represent Bipartite graph for Hopcroft
// Karp implementation
class BipGraph
{
	// m and n are number of vertices on left
	// and right sides of Bipartite Graph
	int m, n;

	// adj[u] stores adjacents of left side
	// vertex 'u'. The value of u ranges from 1 to m.
	// 0 is used for dummy vertex
	list<int> *adj;

	// These are basically pointers to arrays needed
	// for hopcroftKarp()
	int *pairU, *pairV, *dist;

public:
	BipGraph(int m, int n); // Constructor
	void addEdge(int u, int v); // To add edge

	// Returns true if there is an augmenting path
	bool bfs();

	// Adds augmenting path if there is one beginning
	// with u
	bool dfs(int u);

	// Returns size of maximum matcing
	int hopcroftKarp();
};

// Returns size of maximum matching
int BipGraph::hopcroftKarp()
{
    // pairU[u] stores pair of u in matching where u
    // is a vertex on left side of Bipartite Graph.
    // If u doesn't have any pair, then pairU[u] is NIL
	pairU = new int[m+1];

    // pairV[v] stores pair of v in matching. If v
    // doesn't have any pair, then pairU[v] is NIL
	pairV = new int[n+1];

	// dist[u] stores distance of left side vertices
	// dist[u] is one more than dist[u'] if u is next
	// to u'in augmenting path
	dist = new int[m+1];

	// Initialize NIL as pair of all vertices
	for (int u=0; u<m; u++)
		pairU[u] = NIL;
	for (int v=0; v<n; v++)
		pairV[v] = NIL;

	// Initialize result
	int result = 0;

	// Keep updating the result while there is an
	// augmenting path.
	while (bfs())
	{
		// Find a free vertex
		for (int u=1; u<=m; u++)

			// If current vertex is free and there is
			// an augmenting path from current vertex
			if (pairU[u]==NIL &amp;&amp; dfs(u))
				result++;
	}
	return result;
}

// Returns true if there is an augmenting path, else returns
// false
bool BipGraph::bfs()
{
	queue<int> Q; //an integer queue

	// First layer of vertices (set distance as 0)
	for (int u=1; u<=m; u++)
	{
		// If this is a free vertex, add it to queue
		if (pairU[u]==NIL)
		{
			// u is not matched
			dist[u] = 0;
			Q.push(u);
		}

		// Else set distance as infinite so that this vertex
		// is considered next time
		else dist[u] = INF;
	}

	// Initialize distance to NIL as infinite
	dist[NIL] = INF;

	// Q is going to contain vertices of left side only. 
	while (!Q.empty())
	{
		// Dequeue a vertex
		int u = Q.front();
		Q.pop();

		// If this node is not NIL and can provide a shorter path to NIL
		if (dist[u] < dist[NIL])
		{
			// Get all adjacent vertices of the dequeued vertex u
			list<int>::iterator i;
			for (i=adj[u].begin(); i!=adj[u].end(); ++i)
			{
				int v = *i;

				// If pair of v is not considered so far
				// (v, pairV[V]) is not yet explored edge.
				if (dist[pairV[v]] == INF)
				{
					// Consider the pair and add it to queue
					dist[pairV[v]] = dist[u] + 1;
					Q.push(pairV[v]);
				}
			}
		}
	}

	// If we could come back to NIL using alternating path of distinct
	// vertices then there is an augmenting path
	return (dist[NIL] != INF);
}

// Returns true if there is an augmenting path beginning with free vertex u
bool BipGraph::dfs(int u)
{
	if (u != NIL)
	{
		list<int>::iterator i;
		for (i=adj[u].begin(); i!=adj[u].end(); ++i)
		{
			// Adjacent to u
			int v = *i;

			// Follow the distances set by BFS
			if (dist[pairV[v]] == dist[u]+1)
			{
				// If dfs for pair of v also returns
				// true
				if (dfs(pairV[v]) == true)
				{
					pairV[v] = u;
					pairU[u] = v;
					return true;
				}
			}
		}

		// If there is no augmenting path beginning with u.
		dist[u] = INF;
		return false;
	}
	return true;
}

// Constructor
BipGraph::BipGraph(int m, int n)
{
	this->m = m;
	this->n = n;
	adj = new list<int>[m+1];
}

// To add edge from u to v and v to u
void BipGraph::addEdge(int u, int v)
{
	adj[u].push_back(v); // Add u to v’s list.
	adj[v].push_back(u); // Add u to v’s list.
}

// Driver Program
int main()
{
	BipGraph g(4, 4);
	g.addEdge(1, 2);
	g.addEdge(1, 3);
	g.addEdge(2, 1);
	g.addEdge(3, 2);
	g.addEdge(4, 2);
	g.addEdge(4, 4);

	cout << "Size of maximum matching is " << g.hopcroftKarp();

	return 0;
}

