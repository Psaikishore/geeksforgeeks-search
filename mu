2 fundamentals-of-algorithms/
3 fundamentals-of-algorithms/
4 searching-algorithms/
5 sorting-algorithms/
6 graph-data-structure-and-algorithms/
7 bitwise-algorithms/
8 geometric-algorithms/
9 mathematical-algorithms/
10 randomized-algorithms/
11 fundamentals-of-algorithms/
12 greedy-algorithms/
13 dynamic-programming/
14 divide-and-conquer/
15 backtracking-algorithms/
16 fundamentals-of-algorithms/
17 data-structures/
18 array-data-structure/
19 data-structures/linked-list/
20 stack-data-structure/
21 queue-data-structure/
22 data-structures/
23 binary-tree-data-structure/
24 binary-search-tree-data-structure/
25 heap-data-structure/
26 hashing-data-structure/
27 graph-data-structure-and-algorithms/
28 advanced-data-structures/
29 matrix/
30 string-data-structure/
31 data-structures/
32 c/
33 c-plus-plus/
34 java/
35 python/
36 sql-tutorial/
37 company-preparation/
38 interview-preparation-for-software-developer/
39 software-design-patterns/
40 student-corner/
41 campus-ambassador-program-by-geeksforgeeks/
42 geek-of-the-month/
43 testimonials/
44 careers/
45 internship/
46 school-programming/
47 gate-corner-2-gq/
48 gate-corner-2-gq/
49 gate-cs-notes-gq/
50 lmns-gq/
51 original-gate-previous-year-question-papers-cse-and-it-gq/
52 gate-cs-2018-important-dates/
53 articles-on-computer-science-subjects-gq/
54 operating-systems/
55 dbms/
56 computer-network-tutorials/
57 compiler-design-tutorials/
58 web-technology/
59 computer-organization-and-architecture-tutorials/
60 digital-electronics-logic-design-tutorials/
61 engineering-mathematics-tutorials/
62 theory-of-computation-automata-tutorials/
63 advanced-computer-subjects-tutorials/
64 software-engineering-gq/
65 html-and-xml-gq/
66 puzzles/
67 the-technical-scripter-event-by-geeksforgeeks-2/
68 write-interview-experience/
69 must-coding-questions-company-wise/
70 basic/
71 easy/
72 medium/
73 hard/
74 expert/
75 tag/amazon/
76 tag/dynamic-programming/
77 tag/samsung/
78 tags/
79 a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
80 company-preparation/
81 interview-preparation-for-software-developer/
82 software-design-patterns/
83 placements-gq/
84 company-interview-corner/
85 lmns-gq/
86 c/
87 c-plus-plus/
88 java/
89 python/
90 sql-tutorial/
91 school-programming/
92 operating-systems/
93 dbms/
94 computer-network-tutorials/
95 engineering-mathematics-tutorials/
96 web-technology/
97 tag/computer-graphics/
98 image-processing/
99 johnson-trotter-algorithm/
100 easy/
101 johnson-trotter-algorithm/
102 print-reverse-linked-list-without-extra-space-modifications/
103 easy/
104 print-reverse-linked-list-without-extra-space-modifications/
105 tag/programming-puzzle/
106 circular-array/
107 easy/
108 circular-array/
109 tag/circular-array/
110 value-k-th-index-series-formed-append-insert-mex-middle/
111 value-k-th-index-series-formed-append-insert-mex-middle/
112 tag/binary-search/
113 insert-whole-linked-list-k-th-position/
114 insert-whole-linked-list-k-th-position/
115 trinomial-triangle/
116 trinomial-triangle/
117 output-java-programs-set-54-vectors/
118 output-java-programs-set-54-vectors/
119 tag/java-util-package/
120 python-minimum-number-subsets-distinct-elements-using-counter/
121 python-minimum-number-subsets-distinct-elements-using-counter/
122 tag/python-dict/
123 tag/python-set/
124 python-find-number-occurring-odd-number-times-using-lambda-expression-reduce-function/
125 python-find-number-occurring-odd-number-times-using-lambda-expression-reduce-function/
126 tag/python-string/
127 find-minimum-number-operation-make-array-decreasing/
128 find-minimum-number-operation-make-array-decreasing/
129 priority_queuetop-c-stl/
130 priority_queuetop-c-stl/
131 tag/cpp-library/
132 tag/cpp-queue/
133 tag/stl/
134 minimum-equal-palindromic-cuts-with-rearrangements-allowed/
135 minimum-equal-palindromic-cuts-with-rearrangements-allowed/
136 tag/palindrome/
137 priority_queuepush-priority_queuepop-c-stl/
138 priority_queuepush-priority_queuepop-c-stl/
139 tag/cpp-library/
140 tag/cpp-queue/
141 tag/stl/
142 program-find-sum-series-11-22-33-44-55-nn/
143 basic/
144 program-find-sum-series-11-22-33-44-55-nn/
145 tag/number-theory/
146 tag/series/
147 find-largest-sum-digits-divisors-n/
148 find-largest-sum-digits-divisors-n/
149 tag/number-digits/
150 program-get-sum-series-1-x22-x44-upto-nth-term/
151 program-get-sum-series-1-x22-x44-upto-nth-term/
152 tag/factorial/
153 tag/series/
154 iterative-searching-binary-search-tree/
155 iterative-searching-binary-search-tree/
156 smallest-subset-sum-greater-elements/
157 medium/
158 smallest-subset-sum-greater-elements/
159 longest-common-subsequence/
160 breadth-first-traversal-for-a-graph/
161 school-programming/
162 longest-repeated-subsequence/
163 dynamic-programming-set-12-longest-palindromic-subsequence/
164 detect-negative-cycle-graph-bellman-ford/
165 knapsack-problem/
166 gate-cs-notes-gq/
167 depth-first-traversal-for-a-graph/
168 reverse-a-linked-list/
169 top-algorithms-and-data-structures-for-competitive-programming/
170 top-10-algorithms-in-interview-questions/
171 how-to-begin-with-competitive-programming/
172 a-complete-step-by-step-guide-for-placement-preparation-by-geeksforgeeks/
173 how-to-prepare-for-acm-icpc/
174 advanced-data-structures/
175 dynamic-programming/
176 tag/recursion
177 tag/statistical-algorithms/
178 tag/amazon/
179 tag/aptitude/
180 tag/c/
181 tag/cpp-library/
182 tag/data-structures/
183 tag/number-digits/
184 tag/series/
185 tag/stl/
186 recent-comments/
187 careers/




-----------------------------------------------NEXT OPTIONS----------------------------------------
2 breadth-first-traversal-for-a-graph/
3 depth-first-traversal-for-a-graph/
4 applications-of-depth-first-search/
5 applications-of-breadth-first-traversal/
6 graph-representations-using-set-hash/
7 find-a-mother-vertex-in-a-graph/
8 transitive-closure-of-a-graph-using-dfs/
9 find-k-cores-graph/
10 iterative-depth-first-traversal/
11 count-number-nodes-given-level-using-bfs/
12 count-possible-paths-two-vertices/
13 minimum-initial-vertices-traverse-whole-matrix-given-conditions/
14 shortest-path-reach-one-prime-changing-single-digit-time/
15 water-jug-problem-using-bfs/
16 count-number-trees-forest/
17 bfs-using-vectors-queue-per-algorithm-clrs/
18 level-node-tree-source-node-using-bfs/
19 construct-binary-palindrome-by-repeated-appending-and-trimming/
20 transpose-graph/
21 path-rectangle-containing-circles/
22 height-generic-tree-parent-array/
23 bfs-using-stl-competitive-coding/
24 dfs-n-ary-tree-acyclic-graph-represented-adjacency-list/
25 maximum-number-edges-added-tree-stays-bipartite-graph/
26 peterson-graph/
27 print-paths-given-source-destination-using-bfs/
28 minimum-number-of-edges-between-two-vertices-of-a-graph/
29 count-nodes-within-k-distance-from-all-nodes-in-a-set/
30 bidirectional-search/
31 minimum-edge-reversals-to-make-a-root/
32 bfs-disconnected-graph/
33 move-weighting-scale-alternate-given-constraints/
34 best-first-search-informed-search/
35 number-pair-positions-matrix-not-accessible/
36 maximum-product-of-two-non-intersecting-paths-in-a-tree/
37 delete-edge-minimize-subtree-sum-difference/
38 find-minimum-numbers-moves-needed-move-one-cell-matrix-another/
39 minimum-steps-reach-target-knight/
40 minimum-number-operation-required-convert-number-x-y/
41 minimum-steps-reach-end-array-constraints/
42 find-the-smallest-binary-digit-multiple-of-given-number/
43 roots-tree-gives-minimum-height/
44 stepping-numbers/
45 clone-an-undirected-graph/
46 sum-of-the-minimum-elements-in-all-connected-components-of-an-undirected-graph/
47 check-if-two-nodes-are-on-same-path-in-a-tree/
48 a-matrix-probability-question/
49 find-length-largest-region-boolean-matrix/
50 iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/
51 detect-cycle-in-a-graph/
52 detect-cycle-undirected-graph/
53 detect-cycle-direct-graph-using-colors/
54 assign-directions-to-edges-so-that-the-directed-graph-remains-acyclic/
55 detect-negative-cycle-graph-bellman-ford/
56 cycles-of-length-n-in-an-undirected-and-connected-graph/
57 detecting-negative-cycle-using-floyd-warshall/
58 check-if-there-is-a-cycle-with-odd-weight-sum-in-an-undirected-graph/
59 check-graphs-cycle-odd-length/
60 clone-directed-acyclic-graph/
61 check-loop-array-according-given-constraints/
62 union-find/
63 union-find-algorithm-set-2-union-by-rank/
64 union-find-algorithm-union-rank-find-optimized-path-compression/
65 magical-indices-array/
66 topological-sorting/
67 all-topological-sorts-of-a-directed-acyclic-graph/
68 topological-sorting-indegree-based-solution/
69 maximum-edges-can-added-dag-remains-dag/
70 longest-path-between-any-pair-of-vertices/
71 find-longest-path-directed-acyclic-graph/
72 longest-path-directed-acyclic-graph-set-2/
73 topological-sorting-using-departure-time-of-vertex/
74 given-sorted-dictionary-find-precedence-characters/
75 greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/
76 applications-of-minimum-spanning-tree/
77 greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/
78 greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/
79 greedy-algorithms-set-9-boruvkas-algorithm/
80 minimum-cost-connect-cities/
81 steiner-tree/
82 reverse-delete-algorithm-minimum-spanning-tree/
83 total-number-spanning-trees-graph/
84 minimum-product-spanning-tree/
85 find-if-there-is-a-path-of-more-than-k-length-from-a-source/
86 tug-of-war/
87 backtracking-set-1-the-knights-tour-problem/
88 backttracking-set-2-rat-in-a-maze/
89 backtracking-set-3-n-queen-problem/
90 backttracking-set-5-m-coloring-problem/
91 backtracking-set-7-hamiltonian-cycle/
92 permutation-numbers-sum-two-consecutive-numbers-perfect-square/
93 greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/
94 greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/
95 dynamic-programming-set-23-bellman-ford-algorithm/
96 dynamic-programming-set-16-floyd-warshall-algorithm/
97 johnsons-algorithm/
98 shortest-path-for-directed-acyclic-graphs/
99 shortest-path-exactly-k-edges-directed-weighted-graph/
100 dials-algorithm-optimized-dijkstra-for-small-range-weights/
101 printing-paths-dijkstras-shortest-path-algorithm/
102 shortest-path-weighted-graph-weight-edge-1-2/
103 multistage-graph-shortest-path/
104 shortest-path-unweighted-graph/
105 convert-undirected-graph-directed-graph-minimize-disconnected-component/
106 betweenness-centrality-centrality-measure/
107 comparison-dijkstras-floyd-warshall-algorithms/
108 karps-minimum-mean-average-weight-cycle-algorithm/
109 0-1-bfs-shortest-path-binary-graph/
110 find-minimum-weight-cycle-undirected-graph/
111 minimum-cost-path-left-right-bottom-moves-allowed/
112 minimum-edges-reverse-make-path-source-destination/
113 find-shortest-distance-guard-bank/
114 find-if-there-is-a-path-between-two-vertices-in-a-given-graph/
115 connectivity-in-a-directed-graph/
116 articulation-points-or-cut-vertices-in-a-graph/
117 biconnected-components/
118 biconnectivity-in-a-graph/
119 bridge-in-a-graph/
120 eulerian-path-and-circuit/
121 fleurys-algorithm-for-printing-eulerian-path/
122 strongly-connected-components/
123 transitive-closure-of-a-graph/
124 find-number-of-islands/
125 find-the-number-of-islands-set-2-using-disjoint-set/
126 count-possible-paths-source-destination-exactly-k-edges/
127 euler-circuit-directed-graph/
128 count-number-non-reachable-nodes/
129 find-degree-particular-vertex-graph/
130 minimum-edges-required-to-add-to-make-euler-circuit/
131 eulerian-path-undirected-graph/
132 find-if-there-is-a-path-of-more-than-k-length-from-a-source/
133 length-of-shortest-chain-to-reach-a-target-word/
134 find-paths-given-source-destination/
135 find-the-minimum-cost-to-reach-a-destination-where-every-station-is-connected-in-one-direction/
136 given-array-strings-find-strings-can-chained-form-circle/
137 find-array-strings-can-chained-form-circle-set-2/
138 tarjan-algorithm-find-strongly-connected-components/
139 number-ways-node-make-loop-size-k-undirected-complete-connected-graph-n-nodes/
140 paths-travel-nodes-using-edgeseven-bridges-konigsberg/
141 number-of-cyclic-elements-in-an-array-where-we-can-jump-according-to-value/
142 number-groups-formed-graph-friends/
143 minimum-cost-connect-weighted-nodes-represented-array/
144 count-single-node-isolated-sub-graphs-disconnected-graph/
145 number-nodes-two-vertices-acyclic-graph-disjoint-union-method/
146 dynamic-connectivity-set-1-incremental/
147 connectivity-in-a-directed-graph/
148 check-given-directed-graph-strongly-connected-set-2-kosaraju-using-bfs/
149 check-removing-given-edge-disconnects-given-graph/
150 find-all-reachable-nodes-from-every-node-present-in-a-given-set/
151 connected-components-in-an-undirected-graph/
152 kth-adjacent-node-graph-vertex-weight/
153 ford-fulkerson-algorithm-for-maximum-flow-problem/
154 find-edge-disjoint-paths-two-vertices/
155 minimum-cut-in-a-directed-graph/
156 maximum-bipartite-matching/
157 channel-assignment-problem/
158 push-relabel-algorithm-set-1-introduction-and-illustration/
159 push-relabel-algorithm-set-2-implementation/
160 kargers-algorithm-for-minimum-cut-set-1-introduction-and-implementation/
161 kargers-algorithm-for-minimum-cut-set-2-analysis-and-applications/
162 dinics-algorithm-maximum-flow/
163 max-flow-problem-introduction/
164 kruskals-minimum-spanning-tree-using-stl-in-c/
165 prims-algorithm-using-priority_queue-stl/
166 dijkstras-shortest-path-algorithm-using-priority_queue-stl/
167 dijkstras-shortest-path-algorithm-using-set-in-stl/
168 graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/
169 graph-coloring-applications/
170 graph-coloring-set-2-greedy-algorithm/
171 traveling-salesman-problem-tsp-implementation/
172 travelling-salesman-problem-set-1/
173 travelling-salesman-problem-set-2-approximate-using-mst/
174 vertex-cover-problem-set-1-introduction-approximate-algorithm-2/
175 k-centers-problem-set-1-greedy-approximate-algorithm/
176 erdos-renyl-model-generating-random-graphs/
177 clustering-coefficient-graph-theory/
178 chinese-postman-route-inspection-set-1-introduction/
179 hierholzers-algorithm-directed-graph/
180 number-of-triangles-in-a-undirected-graph/
181 number-of-triangles-in-directed-and-undirected-graphs/
182 bipartite-graph/
183 snake-ladder-problem-2/
184 minimize-cash-flow-among-given-set-friends-borrowed-money/
185 boggle-find-possible-words-board-characters/
186 hopcroft-karp-algorithm-for-maximum-matching-set-1-introduction/
187 hopcroft-karp-algorithm-for-maximum-matching-set-2-implementation/
188 minimum-time-required-so-that-all-oranges-become-rotten/
189 find-same-contacts-in-a-list-of-contacts/
190 hypercube-graph/
191 check-star-graph/
192 optimal-read-list-given-number-days/
193 print-all-jumping-numbers-smaller-than-or-equal-to-a-given-value/
194 fibonacci-cube-graph/
195 barabasi-albert-graph-scale-free-models/
196 construct-graph-given-degrees-vertices/
197 degree-centrality-centrality-measure/
198 katz-centrality-centrality-measure/
199 2-satisfiability-2-sat-problem/
200 determine-whether-universal-sink-exists-directed-graph/
201 number-sink-nodes-graph/
202 largest-subset-graph-vertices-edges-2-colors/
203 networkx-python-software-package-study-complex-networks/
204 generate-graph-using-dictionary-python/
205 count-number-edges-undirected-graph/
206 two-clique-problem-check-graph-can-divided-two-cliques/
207 check-whether-given-degrees-vertices-represent-graph-tree/
208 finding-minimum-vertex-cover-graph-using-binary-search/
209 stable-marriage-problem/
210 sum-dependencies-graph/
211 top-10-interview-question-depth-first-search-dfs/
212 interesting-shortest-path-questions-set-1/
213 mit?url=https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/&title=Graph Data Structure And Algorithms
214 





Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree (See method 2 of this post). The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array.  For simplicity, it is assumed that all vertices are reachable from the starting vertex.
For example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process. A Breadth First Traversal of the following graph is 2, 0, 3, 1.



                                        Recommended: Please solve it on &#8220;PRACTICE &#8221; first, before moving on to the solution.
                                    


        
          
          
          
          (adsbygoogle = window.adsbygoogle || []).push({});
        
        
            
Following are the implementations of simple Breadth First Traversal from a given source. 
The implementation uses adjacency list representation of graphs. STL&#8216;s list container is used to store lists of adjacent nodes and queue of nodes needed for BFS traversal.

C++







                                    filter_none

                                    edit
                                    close

                                    play_arrow

                                    link
                                    brightness_4
                                    code
                                










// Program to print BFS traversal from a given 
// source vertex. BFS(int s) traverses vertices 
// reachable from s. 
#include<iostream> 
#include <list> 

using namespace std; 

// This class represents a directed graph using 
// adjacency list representation 
class Graph 
{ 
int V; // No. of vertices 

// Pointer to an array containing adjacency 
// lists 
list<int> *adj; 
public: 
Graph(int V); // Constructor 

// function to add an edge to graph 
void addEdge(int v, int w); 

// prints BFS traversal from a given source s 
void BFS(int s); 
}; 

Graph::Graph(int V) 
{ 
this->V = V; 
adj = new list<int>[V]; 
} 

void Graph::addEdge(int v, int w) 
{ 
adj[v].push_back(w); // Add w to v’s list. 
} 

void Graph::BFS(int s) 
{ 
// Mark all the vertices as not visited 
bool *visited = new bool[V]; 
for(int i = 0; i < V; i++) 
visited[i] = false; 

// Create a queue for BFS 
list<int> queue; 

// Mark the current node as visited and enqueue it 
visited[s] = true; 
queue.push_back(s); 

// 'i' will be used to get all adjacent 
// vertices of a vertex 
list<int>::iterator i; 

while(!queue.empty()) 
{ 
// Dequeue a vertex from queue and print it 
s = queue.front(); 
cout << s << " "; 
queue.pop_front(); 

// Get all adjacent vertices of the dequeued 
// vertex s. If a adjacent has not been visited, 
// then mark it visited and enqueue it 
for (i = adj[s].begin(); i != adj[s].end(); ++i) 
{ 
if (!visited[*i]) 
{ 
visited[*i] = true; 
queue.push_back(*i); 
} 
} 
} 
} 

// Driver program to test methods of graph class 
int main() 
{ 
// Create a graph given in the above diagram 
Graph g(4); 
g.addEdge(0, 1); 
g.addEdge(0, 2); 
g.addEdge(1, 2); 
g.addEdge(2, 0); 
g.addEdge(2, 3); 
g.addEdge(3, 3); 

cout << "Following is Breadth First Traversal "
<< "(starting from vertex 2) \n"; 
g.BFS(2); 

return 0; 
} 










                        chevron_right



                        filter_none




Java







                                    filter_none

                                    edit
                                    close

                                    play_arrow

                                    link
                                    brightness_4
                                    code
                                










// Java program to print BFS traversal from a given source vertex. 
// BFS(int s) traverses vertices reachable from s. 
import java.io.*; 
import java.util.*; 

// This class represents a directed graph using adjacency list 
// representation 
class Graph 
{ 
private int V; // No. of vertices 
private LinkedList<Integer> adj[]; //Adjacency Lists 

// Constructor 
Graph(int v) 
{ 
V = v; 
adj = new LinkedList[v]; 
for (int i=0; i<v; ++i) 
adj[i] = new LinkedList(); 
} 

// Function to add an edge into the graph 
void addEdge(int v,int w) 
{ 
adj[v].add(w); 
} 

// prints BFS traversal from a given source s 
void BFS(int s) 
{ 
// Mark all the vertices as not visited(By default 
// set as false) 
boolean visited[] = new boolean[V]; 

// Create a queue for BFS 
LinkedList<Integer> queue = new LinkedList<Integer>(); 

// Mark the current node as visited and enqueue it 
visited[s]=true; 
queue.add(s); 

while (queue.size() != 0) 
{ 
// Dequeue a vertex from queue and print it 
s = queue.poll(); 
System.out.print(s+" "); 

// Get all adjacent vertices of the dequeued vertex s 
// If a adjacent has not been visited, then mark it 
// visited and enqueue it 
Iterator<Integer> i = adj[s].listIterator(); 
while (i.hasNext()) 
{ 
int n = i.next(); 
if (!visited[n]) 
{ 
visited[n] = true; 
queue.add(n); 
} 
} 
} 
} 

// Driver method to 
public static void main(String args[]) 
{ 
Graph g = new Graph(4); 

g.addEdge(0, 1); 
g.addEdge(0, 2); 
g.addEdge(1, 2); 
g.addEdge(2, 0); 
g.addEdge(2, 3); 
g.addEdge(3, 3); 

System.out.println("Following is Breadth First Traversal "+ 
"(starting from vertex 2)"); 

g.BFS(2); 
} 
} 
// This code is contributed by Aakash Hasija 










                        chevron_right



                        filter_none




Python3







                                    filter_none

                                    edit
                                    close

                                    play_arrow

                                    link
                                    brightness_4
                                    code
                                










# Python3 Program to print BFS traversal 
# from a given source vertex. BFS(int s) 
# traverses vertices reachable from s. 
from collections import defaultdict 

# This class represents a directed graph 
# using adjacency list representation 
class Graph: 

# Constructor 
def __init__(self): 

# default dictionary to store graph 
self.graph = defaultdict(list) 

# function to add an edge to graph 
def addEdge(self,u,v): 
self.graph[u].append(v) 

# Function to print a BFS of graph 
def BFS(self, s): 

# Mark all the vertices as not visited 
visited = [False] * (len(self.graph)) 

# Create a queue for BFS 
queue = [] 

# Mark the source node as 
# visited and enqueue it 
queue.append(s) 
visited[s] = True

while queue: 

# Dequeue a vertex from 
# queue and print it 
s = queue.pop(0) 
print (s, end = " ") 

# Get all adjacent vertices of the 
# dequeued vertex s. If a adjacent 
# has not been visited, then mark it 
# visited and enqueue it 
for i in self.graph[s]: 
if visited[i] == False: 
queue.append(i) 
visited[i] = True

# Driver code 

# Create a graph given in 
# the above diagram 
g = Graph() 
g.addEdge(0, 1) 
g.addEdge(0, 2) 
g.addEdge(1, 2) 
g.addEdge(2, 0) 
g.addEdge(2, 3) 
g.addEdge(3, 3) 

print ("Following is Breadth First Traversal"
" (starting from vertex 2)") 
g.BFS(2) 

# This code is contributed by Neelam Yadav 










                        chevron_right



                        filter_none




